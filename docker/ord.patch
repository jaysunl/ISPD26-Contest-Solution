diff --git a/src/dpl/CMakeLists.txt b/src/dpl/CMakeLists.txt
index 95b4487a41..6c3bbda6a5 100644
--- a/src/dpl/CMakeLists.txt
+++ b/src/dpl/CMakeLists.txt
@@ -52,6 +52,7 @@ target_link_libraries(dpl_lib
     odb
   PRIVATE
     utl_lib
+    dbSta_lib
 )
 
 target_include_directories(dpl_lib
diff --git a/src/dpl/include/dpl/Opendp.h b/src/dpl/include/dpl/Opendp.h
index 22305b8e49..5980302b20 100644
--- a/src/dpl/include/dpl/Opendp.h
+++ b/src/dpl/include/dpl/Opendp.h
@@ -25,6 +25,10 @@ namespace utl {
 class Logger;
 }
 
+namespace sta {
+class dbSta;
+}
+
 namespace dpl {
 
 using utl::Logger;
@@ -132,6 +136,9 @@ class Opendp
   Journal* getJournal() const;
   void setJournal(Journal* journal);
 
+  // Set STA for buffer/inverter detection in soft blockage checks
+  void setSta(sta::dbSta* sta) { sta_ = sta; }
+
  private:
   using bgPoint
       = boost::geometry::model::d2::point_xy<int,
@@ -254,7 +261,8 @@ class Opendp
                     const std::vector<Node*>& region_placement_failures,
                     const std::vector<Node*>& placement_failures,
                     const std::vector<Node*>& edge_spacing_failures,
-                    const std::vector<Node*>& blocked_layers_failures);
+                    const std::vector<Node*>& blocked_layers_failures,
+                    const std::vector<Node*>& soft_blockage_failures);
   void writeJsonReport(const std::string& filename);
 
   void rectDist(const Node* cell,
@@ -309,6 +317,7 @@ class Opendp
   odb::dbDatabase* db_ = nullptr;
   odb::dbBlock* block_ = nullptr;
   odb::Rect core_;
+  sta::dbSta* sta_ = nullptr;  // For buffer/inverter detection
 
   std::unique_ptr<Architecture> arch_;  // Information about rows, etc.
   std::unique_ptr<Network> network_;    // The netlist, cells, etc.
diff --git a/src/dpl/src/CheckPlacement.cpp b/src/dpl/src/CheckPlacement.cpp
index ed2cbd7a89..aa4995f333 100644
--- a/src/dpl/src/CheckPlacement.cpp
+++ b/src/dpl/src/CheckPlacement.cpp
@@ -39,6 +39,7 @@ void Opendp::checkPlacement(const bool verbose,
   std::vector<Node*> region_placement_failures;
   std::vector<Node*> edge_spacing_failures;
   std::vector<Node*> blocked_layers_failures;
+  std::vector<Node*> soft_blockage_failures;
 
   initGrid();
   groupAssignCellRegions();
@@ -82,6 +83,10 @@ void Opendp::checkPlacement(const bool verbose,
     if (!drc_engine_->checkBlockedLayers(cell.get())) {
       blocked_layers_failures.emplace_back(cell.get());
     }
+    // Soft blockage check
+    if (!drc_engine_->checkSoftBlockage(cell.get())) {
+      soft_blockage_failures.emplace_back(cell.get());
+    }
   }
   // This loop is separate because it needs to be done after the overlap check
   // The overlap check assigns the overlap cell to its pixel
@@ -105,7 +110,8 @@ void Opendp::checkPlacement(const bool verbose,
                region_placement_failures,
                {},
                edge_spacing_failures,
-               blocked_layers_failures);
+               blocked_layers_failures,
+               soft_blockage_failures);
   if (!report_file_name.empty()) {
     writeJsonReport(report_file_name);
   }
@@ -122,16 +128,18 @@ void Opendp::checkPlacement(const bool verbose,
   reportFailures(
       edge_spacing_failures, 9, "LEF58_CELLEDGESPACINGTABLE", verbose);
   reportFailures(blocked_layers_failures, 10, "Blocked layers", verbose);
+  reportFailures(soft_blockage_failures, 12, "Soft blockage", verbose);
   logger_->metric("design__violations",
                   placed_failures.size() + in_rows_failures.size()
                       + overlap_failures.size() + padding_failures.size()
-                      + site_align_failures.size());
+                      + site_align_failures.size()
+                      + soft_blockage_failures.size());
 
   if (placed_failures.size() + in_rows_failures.size() + overlap_failures.size()
           + padding_failures.size() + site_align_failures.size()
           + (disallow_one_site_gaps_ ? one_site_gap_failures.size() : 0)
           + region_placement_failures.size() + edge_spacing_failures.size()
-          + blocked_layers_failures.size()
+          + blocked_layers_failures.size() + soft_blockage_failures.size()
       > 0) {
     logger_->error(DPL, 33, "detailed placement checks failed.");
   }
@@ -192,13 +200,15 @@ void Opendp::saveFailures(const vector<Node*>& placed_failures,
                           const vector<Node*>& region_placement_failures,
                           const vector<Node*>& placement_failures,
                           const vector<Node*>& edge_spacing_failures,
-                          const vector<Node*>& blocked_layers_failures)
+                          const vector<Node*>& blocked_layers_failures,
+                          const vector<Node*>& soft_blockage_failures)
 {
   if (placed_failures.empty() && in_rows_failures.empty()
       && overlap_failures.empty() && padding_failures.empty()
       && one_site_gap_failures.empty() && site_align_failures.empty()
       && region_placement_failures.empty() && placement_failures.empty()
-      && edge_spacing_failures.empty() && blocked_layers_failures.empty()) {
+      && edge_spacing_failures.empty() && blocked_layers_failures.empty()
+      && soft_blockage_failures.empty()) {
     return;
   }
 
@@ -268,6 +278,13 @@ void Opendp::saveFailures(const vector<Node*>& placed_failures,
     category->setDescription("Cells that violate the blocked layers.");
     saveViolations(blocked_layers_failures, category);
   }
+  if (!soft_blockage_failures.empty()) {
+    auto category = odb::dbMarkerCategory::createOrReplace(
+        tool_category, "Soft_blockage_failures");
+    category->setDescription(
+        "Regular cells placed in soft blockage regions.");
+    saveViolations(soft_blockage_failures, category);
+  }
 }
 
 void Opendp::writeJsonReport(const std::string& filename)
diff --git a/src/dpl/src/Opendp.cpp b/src/dpl/src/Opendp.cpp
index 21e9e0f0bf..2cd1c82fb9 100644
--- a/src/dpl/src/Opendp.cpp
+++ b/src/dpl/src/Opendp.cpp
@@ -130,7 +130,7 @@ void Opendp::detailedPlacement(const int max_displacement_x,
       logger_->info(DPL, 35, " {}", cell->name());
     }
 
-    saveFailures({}, {}, {}, {}, {}, {}, {}, placement_failures_, {}, {});
+    saveFailures({}, {}, {}, {}, {}, {}, {}, placement_failures_, {}, {}, {});
     if (!report_file_name.empty()) {
       writeJsonReport(report_file_name);
     }
diff --git a/src/dpl/src/PlacementDRC.cpp b/src/dpl/src/PlacementDRC.cpp
index 45660c01fd..f76b191ccf 100644
--- a/src/dpl/src/PlacementDRC.cpp
+++ b/src/dpl/src/PlacementDRC.cpp
@@ -14,6 +14,9 @@
 #include "odb/dbTypes.h"
 #include "odb/geom.h"
 #include "odb/isotropy.h"
+#include "sta/Liberty.hh"
+#include "db_sta/dbNetwork.hh"
+#include "db_sta/dbSta.hh"
 
 namespace dpl {
 
@@ -53,9 +56,11 @@ odb::Rect getQueryRect(const odb::Rect& edge_box, const int spc)
 PlacementDRC::PlacementDRC(Grid* grid,
                            odb::dbTech* tech,
                            Padding* padding,
-                           bool disallow_one_site_gap)
+                           bool disallow_one_site_gap,
+                           sta::dbSta* sta)
     : grid_(grid),
       padding_(padding),
+      sta_(sta),
       disallow_one_site_gap_(disallow_one_site_gap)
 {
   makeCellEdgeSpacingTable(tech);
@@ -190,7 +195,8 @@ bool PlacementDRC::checkDRC(const Node* cell,
                             const odb::dbOrientType& orient) const
 {
   return checkEdgeSpacing(cell, x, y, orient) && checkPadding(cell, x, y)
-         && checkBlockedLayers(cell, x, y) && checkOneSiteGap(cell, x, y);
+         && checkBlockedLayers(cell, x, y) && checkOneSiteGap(cell, x, y)
+         && checkSoftBlockage(cell, x, y);
 }
 
 namespace {
@@ -429,4 +435,114 @@ DbuX PlacementDRC::gridToDbu(const GridX grid_x, const DbuX site_width) const
   return DbuX(grid_x.v * site_width.v);
 }
 
+bool PlacementDRC::isAllowedInSoftBlockage(const Node* cell) const
+{
+  if (cell == nullptr) {
+    return true;  // No cell = no violation
+  }
+
+  odb::dbInst* db_inst = cell->getDbInst();
+  if (db_inst == nullptr) {
+    return true;
+  }
+
+  // Fixed instances are always allowed in soft blockage
+  if (db_inst->isFixed()) {
+    return true;
+  }
+
+  odb::dbMaster* master = db_inst->getMaster();
+  odb::dbMasterType type = master->getType();
+
+  // Physical cells are allowed (endcaps, tapcells, fillers, tie cells)
+  switch (type.getValue()) {
+    case odb::dbMasterType::CORE_SPACER:  // Filler cells
+    case odb::dbMasterType::CORE_WELLTAP:
+    case odb::dbMasterType::CORE_TIEHIGH:
+    case odb::dbMasterType::CORE_TIELOW:
+    case odb::dbMasterType::ENDCAP:
+    case odb::dbMasterType::ENDCAP_PRE:
+    case odb::dbMasterType::ENDCAP_POST:
+    case odb::dbMasterType::ENDCAP_TOPLEFT:
+    case odb::dbMasterType::ENDCAP_TOPRIGHT:
+    case odb::dbMasterType::ENDCAP_BOTTOMLEFT:
+    case odb::dbMasterType::ENDCAP_BOTTOMRIGHT:
+    case odb::dbMasterType::ENDCAP_LEF58_BOTTOMEDGE:
+    case odb::dbMasterType::ENDCAP_LEF58_TOPEDGE:
+    case odb::dbMasterType::ENDCAP_LEF58_RIGHTEDGE:
+    case odb::dbMasterType::ENDCAP_LEF58_LEFTEDGE:
+    case odb::dbMasterType::ENDCAP_LEF58_RIGHTBOTTOMEDGE:
+    case odb::dbMasterType::ENDCAP_LEF58_LEFTBOTTOMEDGE:
+    case odb::dbMasterType::ENDCAP_LEF58_RIGHTTOPEDGE:
+    case odb::dbMasterType::ENDCAP_LEF58_LEFTTOPEDGE:
+    case odb::dbMasterType::ENDCAP_LEF58_RIGHTBOTTOMCORNER:
+    case odb::dbMasterType::ENDCAP_LEF58_LEFTBOTTOMCORNER:
+    case odb::dbMasterType::ENDCAP_LEF58_RIGHTTOPCORNER:
+    case odb::dbMasterType::ENDCAP_LEF58_LEFTTOPCORNER:
+      return true;
+    default:
+      break;
+  }
+
+  // Buffer and inverter detection via OpenSTA
+  if (sta_ != nullptr) {
+    sta::dbNetwork* network = sta_->getDbNetwork();
+    if (network != nullptr) {
+      sta::Cell* sta_cell = network->dbToSta(master);
+      if (sta_cell != nullptr) {
+        sta::LibertyCell* lib_cell = network->libertyCell(sta_cell);
+        if (lib_cell != nullptr
+            && (lib_cell->isBuffer() || lib_cell->isInverter())) {
+          return true;
+        }
+      }
+    }
+  }
+
+  // Fallback: detect buffers/inverters/tie cells by master name pattern when STA not available
+  // Common naming conventions: BUF_*, INV_*, CLKBUF_*, CLKINV_*, TIE*, etc.
+  std::string master_name = master->getName();
+  // Convert to uppercase for case-insensitive matching
+  std::transform(
+      master_name.begin(), master_name.end(), master_name.begin(), ::toupper);
+  if (master_name.find("BUF") != std::string::npos
+      || master_name.find("INV") != std::string::npos
+      || master_name.find("TIE") != std::string::npos) {
+    return true;
+  }
+
+  // Regular cells are NOT allowed in soft blockage
+  return false;
+}
+
+bool PlacementDRC::checkSoftBlockage(const Node* cell) const
+{
+  return checkSoftBlockage(cell, grid_->gridX(cell), grid_->gridRoundY(cell));
+}
+
+bool PlacementDRC::checkSoftBlockage(const Node* cell,
+                                      const GridX x,
+                                      const GridY y) const
+{
+  // If cell is allowed in soft blockage, no need to check pixels
+  if (isAllowedInSoftBlockage(cell)) {
+    return true;
+  }
+
+  // Check all pixels the cell would occupy
+  const GridX x_end = x + grid_->gridWidth(cell);
+  const GridY y_end
+      = grid_->gridEndY(grid_->gridYToDbu(y) + cell->getHeight());
+
+  for (GridY y1 = y; y1 < y_end; y1++) {
+    for (GridX x1 = x; x1 < x_end; x1++) {
+      const Pixel* pixel = grid_->gridPixel(x1, y1);
+      if (pixel != nullptr && pixel->is_soft_blocked) {
+        return false;  // Cell overlaps soft blockage and is not allowed
+      }
+    }
+  }
+  return true;  // No soft blockage violation
+}
+
 }  // namespace dpl
diff --git a/src/dpl/src/PlacementDRC.h b/src/dpl/src/PlacementDRC.h
index 71003b55ff..69ef29dc56 100644
--- a/src/dpl/src/PlacementDRC.h
+++ b/src/dpl/src/PlacementDRC.h
@@ -12,6 +12,10 @@ class dbTech;
 class dbOrientType;
 }  // namespace odb
 
+namespace sta {
+class dbSta;
+}  // namespace sta
+
 namespace dpl {
 class Grid;
 class Node;
@@ -38,7 +42,8 @@ class PlacementDRC
   PlacementDRC(Grid* grid,
                odb::dbTech* tech,
                Padding* padding,
-               bool disallow_one_site_gap);
+               bool disallow_one_site_gap,
+               sta::dbSta* sta = nullptr);
   bool checkEdgeSpacing(const Node* cell) const;
   // Check edge spacing for a cell at a given location and orientation
   bool checkEdgeSpacing(const Node* cell,
@@ -55,6 +60,12 @@ class PlacementDRC
   bool checkOneSiteGap(const Node* cell) const;
   bool checkOneSiteGap(const Node* cell, GridX x, GridY y) const;
 
+  // Check soft blockage - regular cells cannot be placed in soft blockage
+  bool checkSoftBlockage(const Node* cell) const;
+  bool checkSoftBlockage(const Node* cell, GridX x, GridY y) const;
+  // Returns true if cell type is allowed in soft blockage regions
+  bool isAllowedInSoftBlockage(const Node* cell) const;
+
   // aggregate function to check against all DRC types
   bool checkDRC(const Node* cell) const;
   bool checkDRC(const Node* cell,
@@ -70,6 +81,7 @@ class PlacementDRC
   // Member variables
   Grid* grid_{nullptr};        // Pointer to the grid for placement
   Padding* padding_{nullptr};  // Pointer to the padding
+  sta::dbSta* sta_{nullptr};   // Pointer to STA for buffer/inverter detection
   std::unordered_map<std::string, int> edge_types_indices_;
   std::vector<std::vector<EdgeSpacingEntry>>
       edge_spacing_table_;  // LEF58_CELLEDGESPACINGTABLE between edge type
diff --git a/src/dpl/src/dbToOpendp.cpp b/src/dpl/src/dbToOpendp.cpp
index ebb0cf3bf1..e955f0d017 100644
--- a/src/dpl/src/dbToOpendp.cpp
+++ b/src/dpl/src/dbToOpendp.cpp
@@ -60,7 +60,11 @@ void Opendp::importClear()
 void Opendp::initPlacementDRC()
 {
   drc_engine_ = std::make_unique<PlacementDRC>(
-      grid_.get(), db_->getTech(), padding_.get(), !odb::hasOneSiteMaster(db_));
+      grid_.get(),
+      db_->getTech(),
+      padding_.get(),
+      !odb::hasOneSiteMaster(db_),
+      sta_);
 }
 
 static bool swapWidthHeight(const dbOrientType& orient)
diff --git a/src/dpl/src/infrastructure/Grid.cpp b/src/dpl/src/infrastructure/Grid.cpp
index 4541465283..a210edbab7 100644
--- a/src/dpl/src/infrastructure/Grid.cpp
+++ b/src/dpl/src/infrastructure/Grid.cpp
@@ -81,6 +81,7 @@ void Grid::allocateGrid()
       pixel.is_valid = false;
       pixel.is_hopeless = false;
       pixel.blocked_layers = 0;
+      pixel.is_soft_blocked = false;
     }
   }
 
@@ -190,24 +191,33 @@ void Grid::markBlocked(odb::dbBlock* block)
     }
   }
   for (odb::dbBlockage* blockage : block->getBlockages()) {
-    if (blockage->isSoft()) {
-      continue;
-    }
     odb::Rect bbox = blockage->getBBox()->getBox();
     bbox.moveDelta(-core.xMin(), -core.yMin());
     GridRect grid_rect = gridCovering(bbox);
 
     // Clip to the core area
-    GridRect core{.xlo = GridX{0},
-                  .ylo = GridY{0},
-                  .xhi = GridX{row_site_count_},
-                  .yhi = GridY{row_count_}};
-    grid_rect = grid_rect.intersect(core);
+    GridRect core_rect{.xlo = GridX{0},
+                       .ylo = GridY{0},
+                       .xhi = GridX{row_site_count_},
+                       .yhi = GridY{row_count_}};
+    grid_rect = grid_rect.intersect(core_rect);
 
-    for (GridY y = grid_rect.ylo; y < grid_rect.yhi; y++) {
-      for (GridX x = grid_rect.xlo; x < grid_rect.xhi; x++) {
-        Pixel& pixel1 = pixel(y, x);
-        pixel1.is_valid = false;
+    if (blockage->isSoft()) {
+      // Soft blockage: mark pixels as soft blocked
+      // Allows buffers/inverters/physical cells but blocks regular cells
+      for (GridY y = grid_rect.ylo; y < grid_rect.yhi; y++) {
+        for (GridX x = grid_rect.xlo; x < grid_rect.xhi; x++) {
+          Pixel& pixel1 = pixel(y, x);
+          pixel1.is_soft_blocked = true;
+        }
+      }
+    } else {
+      // Hard blockage: mark pixels as invalid
+      for (GridY y = grid_rect.ylo; y < grid_rect.yhi; y++) {
+        for (GridX x = grid_rect.xlo; x < grid_rect.xhi; x++) {
+          Pixel& pixel1 = pixel(y, x);
+          pixel1.is_valid = false;
+        }
       }
     }
   }
diff --git a/src/dpl/src/infrastructure/Grid.h b/src/dpl/src/infrastructure/Grid.h
index 0ec536ace6..bb9f9f35d3 100644
--- a/src/dpl/src/infrastructure/Grid.h
+++ b/src/dpl/src/infrastructure/Grid.h
@@ -45,6 +45,8 @@ struct Pixel
   uint8_t blocked_layers = 0;
   // Cell that reserved this pixel for padding
   Node* padding_reserved_by = nullptr;
+  // Soft blockage - blocks regular cells but allows buffers/inverters/physical
+  bool is_soft_blocked = false;
 };
 
 // Return value for grid searches.
diff --git a/src/odb/src/swig/tcl/dbtypes.i b/src/odb/src/swig/tcl/dbtypes.i
index 2f2e85c90a..8f86a71796 100644
--- a/src/odb/src/swig/tcl/dbtypes.i
+++ b/src/odb/src/swig/tcl/dbtypes.i
@@ -44,6 +44,10 @@
     }
 }
 
+%typemap(out) uint8_t {
+    Tcl_SetIntObj($result, (int) $1);
+}
+
 // Wrapper for dbSet, dbVector...etc
 %define WRAP_DB_CONTAINER(T) 
 
